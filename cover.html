
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>widget: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/watzon/tide/pkg/widget/build_context.go (100.0%)</option>
				
				<option value="file1">github.com/watzon/tide/pkg/widget/constraints.go (100.0%)</option>
				
				<option value="file2">github.com/watzon/tide/pkg/widget/edge_insets.go (100.0%)</option>
				
				<option value="file3">github.com/watzon/tide/pkg/widget/element.go (94.2%)</option>
				
				<option value="file4">github.com/watzon/tide/pkg/widget/layout_constraints.go (100.0%)</option>
				
				<option value="file5">github.com/watzon/tide/pkg/widget/render_object.go (100.0%)</option>
				
				<option value="file6">github.com/watzon/tide/pkg/widget/style.go (98.2%)</option>
				
				<option value="file7">github.com/watzon/tide/pkg/widget/widget.go (95.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright (c) 2024 Christopher Watson
//
// This software is released under the MIT License.
// https://opensource.org/licenses/MIT

package widget

import (
        "github.com/watzon/tide/pkg/core/geometry"
        "github.com/watzon/tide/pkg/engine"
)

// BuildContext provides context for widget building
type BuildContext interface {
        // Tree traversal
        Parent() BuildContext

        // Widget information
        Widget() Widget
        Element() Element

        // Layout information
        Size() geometry.Size
        Constraints() Constraints

        // Invalidation
        MarkNeedsBuild()

        // Rendering
        RenderContext() engine.RenderContext
}

// ElementBuildContext implements BuildContext for Elements
type ElementBuildContext struct {
        element Element
}

func NewElementBuildContext(element Element) BuildContext <span class="cov8" title="1">{
        return &amp;ElementBuildContext{
                element: element,
        }
}</span>

// Tree traversal
func (c *ElementBuildContext) Parent() BuildContext <span class="cov8" title="1">{
        if parent := c.element.Parent(); parent != nil </span><span class="cov8" title="1">{
                return parent.BuildContext()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Widget information
func (c *ElementBuildContext) Widget() Widget <span class="cov8" title="1">{
        return c.element.Widget()
}</span>

func (c *ElementBuildContext) Element() Element <span class="cov8" title="1">{
        return c.element
}</span>

// Layout information
func (c *ElementBuildContext) Size() geometry.Size <span class="cov8" title="1">{
        return c.Widget().GetSize()
}</span>

func (c *ElementBuildContext) Constraints() Constraints <span class="cov8" title="1">{
        return c.Widget().GetConstraints()
}</span>

// Invalidation
func (c *ElementBuildContext) MarkNeedsBuild() <span class="cov8" title="1">{
        c.element.MarkNeedsBuild()
}</span>

// Rendering
func (c *ElementBuildContext) RenderContext() engine.RenderContext <span class="cov8" title="1">{
        // Walk up the tree to find the nearest RenderContext
        current := c.element
        for current != nil </span><span class="cov8" title="1">{
                if ctx, ok := current.(RenderContextProvider); ok </span><span class="cov8" title="1">{
                        return ctx.GetRenderContext()
                }</span>
                <span class="cov8" title="1">current = current.Parent()</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// RenderContextProvider allows elements to provide render context
type RenderContextProvider interface {
        GetRenderContext() engine.RenderContext
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package widget

import (
        "fmt"
        "math"

        "github.com/watzon/tide/internal/utils"
        "github.com/watzon/tide/pkg/core/geometry"
)

// Constraints defines the rules for laying out widgets
type Constraints struct {
        // MinSize defines the minimum allowed size
        MinSize geometry.Size
        // MaxSize defines the maximum allowed size
        MaxSize geometry.Size
}

// Common constraint configurations
var (
        // ConstraintsUnbounded represents constraints with no limits
        ConstraintsUnbounded = Constraints{
                MinSize: geometry.Size{Width: 0, Height: 0},
                MaxSize: geometry.Size{
                        Width:  math.MaxInt32,
                        Height: math.MaxInt32,
                },
        }

        // ConstraintsTight forces a specific size
        ConstraintsTight = func(size geometry.Size) Constraints <span class="cov8" title="1">{
                return Constraints{
                        MinSize: size,
                        MaxSize: size,
                }
        }</span>
)

// NewConstraints creates constraints with the given bounds
func NewConstraints(minSize, maxSize geometry.Size) Constraints <span class="cov8" title="1">{
        return Constraints{
                MinSize: minSize,
                MaxSize: maxSize,
        }
}</span>

// WithMinSize returns new constraints with the given minimum size
func (c Constraints) WithMinSize(size geometry.Size) Constraints <span class="cov8" title="1">{
        // If new min size is larger than current max size,
        // both min and max should become the new min size
        if size.Width &gt; c.MaxSize.Width || size.Height &gt; c.MaxSize.Height </span><span class="cov8" title="1">{
                return Constraints{
                        MinSize: size,
                        MaxSize: size,
                }
        }</span>
        <span class="cov8" title="1">return Constraints{
                MinSize: size,
                MaxSize: c.MaxSize,
        }</span>
}

// WithMaxSize returns new constraints with the given maximum size
func (c Constraints) WithMaxSize(size geometry.Size) Constraints <span class="cov8" title="1">{
        // If new max size is smaller than current min size,
        // both min and max should become the new max size
        if size.Width &lt; c.MinSize.Width || size.Height &lt; c.MinSize.Height </span><span class="cov8" title="1">{
                return Constraints{
                        MinSize: size,
                        MaxSize: size,
                }
        }</span>
        <span class="cov8" title="1">return Constraints{
                MinSize: c.MinSize,
                MaxSize: size,
        }</span>
}

// Normalize ensures constraints are valid
func (c Constraints) Normalize() Constraints <span class="cov8" title="1">{
        // Ensure min &lt;= max
        return Constraints{
                MinSize: geometry.Size{
                        Width:  min(c.MinSize.Width, c.MaxSize.Width),
                        Height: min(c.MinSize.Height, c.MaxSize.Height),
                },
                MaxSize: geometry.Size{
                        Width:  max(c.MinSize.Width, c.MaxSize.Width),
                        Height: max(c.MinSize.Height, c.MaxSize.Height),
                },
        }
}</span>

// Constrain forces a size to fit within the constraints
func (c Constraints) Constrain(size geometry.Size) geometry.Size <span class="cov8" title="1">{
        return geometry.Size{
                Width:  utils.ClampInt(size.Width, c.MinSize.Width, c.MaxSize.Width),
                Height: utils.ClampInt(size.Height, c.MinSize.Height, c.MaxSize.Height),
        }
}</span>

// IsSatisfiedBy checks if a size satisfies the constraints
func (c Constraints) IsSatisfiedBy(size geometry.Size) bool <span class="cov8" title="1">{
        return size.Width &gt;= c.MinSize.Width &amp;&amp;
                size.Width &lt;= c.MaxSize.Width &amp;&amp;
                size.Height &gt;= c.MinSize.Height &amp;&amp;
                size.Height &lt;= c.MaxSize.Height
}</span>

// HasTightWidth returns true if the width is tightly constrained
func (c Constraints) HasTightWidth() bool <span class="cov8" title="1">{
        return c.MinSize.Width == c.MaxSize.Width
}</span>

// HasTightHeight returns true if the height is tightly constrained
func (c Constraints) HasTightHeight() bool <span class="cov8" title="1">{
        return c.MinSize.Height == c.MaxSize.Height
}</span>

// IsTight returns true if both dimensions are tightly constrained
func (c Constraints) IsTight() bool <span class="cov8" title="1">{
        return c.HasTightWidth() &amp;&amp; c.HasTightHeight()
}</span>

// IsNormalized returns true if the constraints are valid
func (c Constraints) IsNormalized() bool <span class="cov8" title="1">{
        return c.MinSize.Width &lt;= c.MaxSize.Width &amp;&amp;
                c.MinSize.Height &lt;= c.MaxSize.Height
}</span>

// String provides a readable representation of constraints
func (c Constraints) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("Constraints(min: %v, max: %v)", c.MinSize, c.MaxSize)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright (c) 2024 Chris Watson
//
// This software is released under the MIT License.
// https://opensource.org/licenses/MIT

package widget

import "github.com/watzon/tide/internal/utils"

// EdgeInsets represents spacing measurements for all four edges
type EdgeInsets struct {
        Top    int
        Right  int
        Bottom int
        Left   int
}

// Common EdgeInsets configurations
var (
        // EdgeInsetsZero represents zero insets on all sides
        EdgeInsetsZero = EdgeInsets{}

        // EdgeInsetsAll creates equal insets on all sides
        EdgeInsetsAll = func(value int) EdgeInsets <span class="cov8" title="1">{
                return EdgeInsets{
                        Top:    value,
                        Right:  value,
                        Bottom: value,
                        Left:   value,
                }
        }</span>

        // EdgeInsetsSymmetric creates symmetric horizontal and vertical insets
        EdgeInsetsSymmetric = func(vertical, horizontal int) EdgeInsets <span class="cov8" title="1">{
                return EdgeInsets{
                        Top:    vertical,
                        Right:  horizontal,
                        Bottom: vertical,
                        Left:   horizontal,
                }
        }</span>
)

// Constructor functions

// NewEdgeInsets creates EdgeInsets with specific values for each side
func NewEdgeInsets(top, right, bottom, left int) EdgeInsets <span class="cov8" title="1">{
        return EdgeInsets{
                Top:    top,
                Right:  right,
                Bottom: bottom,
                Left:   left,
        }
}</span>

// Helper methods

// Horizontal returns the total horizontal insets (left + right)
func (e EdgeInsets) Horizontal() int <span class="cov8" title="1">{
        return e.Left + e.Right
}</span>

// Vertical returns the total vertical insets (top + bottom)
func (e EdgeInsets) Vertical() int <span class="cov8" title="1">{
        return e.Top + e.Bottom
}</span>

// Add combines two EdgeInsets
func (e EdgeInsets) Add(other EdgeInsets) EdgeInsets <span class="cov8" title="1">{
        return EdgeInsets{
                Top:    e.Top + other.Top,
                Right:  e.Right + other.Right,
                Bottom: e.Bottom + other.Bottom,
                Left:   e.Left + other.Left,
        }
}</span>

// Scale multiplies all insets by a factor
func (e EdgeInsets) Scale(factor int) EdgeInsets <span class="cov8" title="1">{
        return EdgeInsets{
                Top:    e.Top * factor,
                Right:  e.Right * factor,
                Bottom: e.Bottom * factor,
                Left:   e.Left * factor,
        }
}</span>

// IsZero returns true if all insets are zero
func (e EdgeInsets) IsZero() bool <span class="cov8" title="1">{
        return e.Top == 0 &amp;&amp; e.Right == 0 &amp;&amp; e.Bottom == 0 &amp;&amp; e.Left == 0
}</span>

// Max returns EdgeInsets with the maximum value between two EdgeInsets for each side
func (e EdgeInsets) Max(other EdgeInsets) EdgeInsets <span class="cov8" title="1">{
        return EdgeInsets{
                Top:    max(e.Top, other.Top),
                Right:  max(e.Right, other.Right),
                Bottom: max(e.Bottom, other.Bottom),
                Left:   max(e.Left, other.Left),
        }
}</span>

// Min returns EdgeInsets with the minimum value between two EdgeInsets for each side
func (e EdgeInsets) Min(other EdgeInsets) EdgeInsets <span class="cov8" title="1">{
        return EdgeInsets{
                Top:    min(e.Top, other.Top),
                Right:  min(e.Right, other.Right),
                Bottom: min(e.Bottom, other.Bottom),
                Left:   min(e.Left, other.Left),
        }
}</span>

// Clamp ensures all insets are within a range
func (e EdgeInsets) Clamp(min, max int) EdgeInsets <span class="cov8" title="1">{
        return EdgeInsets{
                Top:    utils.ClampInt(e.Top, min, max),
                Right:  utils.ClampInt(e.Right, min, max),
                Bottom: utils.ClampInt(e.Bottom, min, max),
                Left:   utils.ClampInt(e.Left, min, max),
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright (c) 2024 Christopher Watson
//
// This software is released under the MIT License.
// https://opensource.org/licenses/MIT

package widget

// Element represents a widget instance in the tree
type Element interface {
        // Tree structure
        Parent() Element
        Children() []Element

        // Lifecycle
        Mount(parent Element)
        Unmount()

        // Updates
        Update(Widget)
        MarkNeedsBuild()
        RebuildIfNeeded()

        // Access
        Widget() Widget
        RenderObject() RenderObject
        BuildContext() BuildContext

        // ReplaceChild
        ReplaceChild(old, new Element)

        // Layout phase
        LayoutPhase()
        NeedsLayout() bool
        MarkNeedsLayout()
}

// BaseElement provides common element functionality
type BaseElement struct {
        widget       Widget
        parent       Element
        children     []Element
        renderObject RenderObject
        dirty        bool
        mounted      bool
        needsLayout  bool
}

func (e *BaseElement) Parent() Element <span class="cov8" title="1">{
        return e.parent
}</span>

func (e *BaseElement) Children() []Element <span class="cov8" title="1">{
        return e.children
}</span>

func (e *BaseElement) Widget() Widget <span class="cov8" title="1">{
        return e.widget
}</span>

func (e *BaseElement) RenderObject() RenderObject <span class="cov0" title="0">{
        return e.renderObject
}</span>

func (e *BaseElement) Mount(parent Element) <span class="cov8" title="1">{
        if e.mounted </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">e.parent = parent
        e.mounted = true

        // Create render object
        e.renderObject = e.widget.CreateRenderObject()

        // Initial build
        e.Build()</span>
}

func (e *BaseElement) Unmount() <span class="cov8" title="1">{
        if !e.mounted </span><span class="cov8" title="1">{
                return
        }</span>

        // Unmount children first
        <span class="cov8" title="1">for _, child := range e.children </span><span class="cov8" title="1">{
                child.Unmount()
        }</span>

        <span class="cov8" title="1">e.mounted = false
        e.parent = nil
        e.children = nil
        e.renderObject = nil</span>
}

func (e *BaseElement) Build() <span class="cov8" title="1">{
        if !e.mounted </span><span class="cov8" title="1">{
                return
        }</span>

        // Build new widget
        <span class="cov8" title="1">newWidget := e.widget.Build(e.BuildContext())
        if newWidget == e.widget </span><span class="cov8" title="1">{
                // If the widget returns itself, don't create a new child
                e.dirty = false
                return
        }</span>

        // Update or create child element
        <span class="cov8" title="1">if len(e.children) &gt; 0 </span><span class="cov8" title="1">{
                e.children[0].Update(newWidget)
        }</span> else<span class="cov8" title="1"> {
                child := NewElement(newWidget)
                e.children = append(e.children, child)
                child.Mount(e)
        }</span>

        <span class="cov8" title="1">e.dirty = false</span>
}

func (e *BaseElement) Update(newWidget Widget) <span class="cov8" title="1">{
        // Check if widget types are different using type assertion
        _, oldIsMock := e.widget.(*MockWidget)
        _, newIsMock := newWidget.(*MockWidget)

        if oldIsMock != newIsMock </span><span class="cov8" title="1">{
                // Replace entire element if widget type changes
                if e.parent != nil </span><span class="cov8" title="1">{
                        newElement := NewElement(newWidget)
                        e.parent.ReplaceChild(e, newElement)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">e.widget = newWidget
        e.widget.UpdateRenderObject(e.renderObject)
        e.MarkNeedsBuild()</span>
}

func (e *BaseElement) MarkNeedsBuild() <span class="cov8" title="1">{
        e.dirty = true
        // Propagate to parent if needed
        if e.parent != nil </span><span class="cov8" title="1">{
                e.parent.MarkNeedsBuild()
        }</span>
}

func (e *BaseElement) RebuildIfNeeded() <span class="cov8" title="1">{
        if e.dirty </span><span class="cov8" title="1">{
                e.Build()
        }</span>
}

func (e *BaseElement) BuildContext() BuildContext <span class="cov8" title="1">{
        return &amp;ElementBuildContext{element: e}
}</span>

func (e *BaseElement) ReplaceChild(old, new Element) <span class="cov8" title="1">{
        for i, child := range e.children </span><span class="cov8" title="1">{
                if child == old </span><span class="cov8" title="1">{
                        // Unmount old child
                        old.Unmount()

                        // Mount new child
                        e.children[i] = new
                        new.Mount(e)

                        // Mark parent as needing rebuild
                        e.MarkNeedsBuild()
                        return
                }</span>
        }
}

// NewElement creates the appropriate element type for a widget
func NewElement(widget Widget) Element <span class="cov8" title="1">{
        // switch w := widget.(type) {
        // case StatefulWidget:
        //         return NewStatefulElement(w)
        // case StatelessWidget:
        //         return NewStatelessElement(w)
        // default:
        //         // For basic widgets that just implement Widget interface
        elem := &amp;BaseElement{}
        elem.widget = widget
        return elem
        // }
}</span>

func (e *BaseElement) LayoutPhase() <span class="cov8" title="1">{
        if !e.needsLayout </span><span class="cov0" title="0">{
                return
        }</span>

        // Layout this element's render object
        <span class="cov8" title="1">if e.renderObject != nil </span><span class="cov8" title="1">{
                e.renderObject.Layout(e.widget.GetConstraints())
        }</span>

        // Layout children
        <span class="cov8" title="1">for _, child := range e.children </span><span class="cov0" title="0">{
                child.LayoutPhase()
        }</span>

        <span class="cov8" title="1">e.needsLayout = false</span>
}

func (e *BaseElement) NeedsLayout() bool <span class="cov0" title="0">{
        return e.needsLayout
}</span>

func (e *BaseElement) MarkNeedsLayout() <span class="cov8" title="1">{
        e.needsLayout = true
        // Propagate to parent
        if e.parent != nil </span><span class="cov8" title="1">{
                e.parent.MarkNeedsLayout()
        }</span>
}

// MockElement implements Element interface for testing
type MockElement struct {
        BaseElement
        parent       Element
        buildContext BuildContext
}

func (e *MockElement) Parent() Element <span class="cov8" title="1">{
        return e.parent
}</span>

func (e *MockElement) BuildContext() BuildContext <span class="cov8" title="1">{
        return e.buildContext
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package widget

import (
        "math"

        "github.com/watzon/tide/pkg/core/geometry"
)

// AxisConstraints represents constraints along a single axis
type AxisConstraints struct {
        Min int
        Max int
}

// BoxConstraints represents constraints for box-model layouts
type BoxConstraints struct {
        MinWidth  int
        MaxWidth  int
        MinHeight int
        MaxHeight int
}

// ToConstraints converts BoxConstraints to regular Constraints
func (bc BoxConstraints) ToConstraints() Constraints <span class="cov8" title="1">{
        return Constraints{
                MinSize: geometry.Size{
                        Width:  bc.MinWidth,
                        Height: bc.MinHeight,
                },
                MaxSize: geometry.Size{
                        Width:  bc.MaxWidth,
                        Height: bc.MaxHeight,
                },
        }
}</span>

// LooseConstraints creates constraints that must be at least a given size
func LooseConstraints(minSize geometry.Size) Constraints <span class="cov8" title="1">{
        return Constraints{
                MinSize: minSize,
                MaxSize: geometry.Size{
                        Width:  math.MaxInt32,
                        Height: math.MaxInt32,
                },
        }
}</span>

// TightConstraints creates constraints for an exact size
func TightConstraints(size geometry.Size) Constraints <span class="cov8" title="1">{
        return Constraints{
                MinSize: size,
                MaxSize: size,
        }
}</span>

// ExpandedConstraints creates constraints that fill available space
func ExpandedConstraints(maxSize geometry.Size) Constraints <span class="cov8" title="1">{
        return Constraints{
                MinSize: maxSize,
                MaxSize: maxSize,
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright (c) 2024 Christopher Watson
//
// This software is released under the MIT License.
// https://opensource.org/licenses/MIT

package widget

import (
        "github.com/watzon/tide/pkg/core/geometry"
        "github.com/watzon/tide/pkg/engine"
)

// RenderObject is the base interface for all render objects
type RenderObject interface {
        // Layout and sizing
        Layout(constraints Constraints) geometry.Size
        Size() geometry.Size
        Constraints() Constraints

        // Parent/child relationships
        Parent() RenderObject
        Children() []RenderObject

        // Style and appearance
        Style() WidgetStyle

        // Backend-specific rendering
        Paint(context engine.RenderContext)
}

// BaseRenderObject provides default implementation for RenderObjects
type BaseRenderObject struct {
        size        geometry.Size
        constraints Constraints
        style       WidgetStyle
        parent      RenderObject
        children    []RenderObject
}

// Layout and sizing
func (r *BaseRenderObject) Layout(constraints Constraints) geometry.Size <span class="cov8" title="1">{
        r.constraints = constraints
        // Default layout just uses minimum size
        r.size = constraints.Constrain(constraints.MinSize)
        return r.size
}</span>

func (r *BaseRenderObject) Size() geometry.Size <span class="cov8" title="1">{
        return r.size
}</span>

func (r *BaseRenderObject) Constraints() Constraints <span class="cov8" title="1">{
        return r.constraints
}</span>

// Parent/child relationships
func (r *BaseRenderObject) Parent() RenderObject <span class="cov8" title="1">{
        return r.parent
}</span>

func (r *BaseRenderObject) Children() []RenderObject <span class="cov8" title="1">{
        return r.children
}</span>

// Style access
func (r *BaseRenderObject) Style() WidgetStyle <span class="cov8" title="1">{
        return r.style
}</span>

// Child management
func (r *BaseRenderObject) AppendChild(child RenderObject) <span class="cov8" title="1">{
        if baseChild, ok := child.(*BaseRenderObject); ok </span><span class="cov8" title="1">{
                baseChild.parent = r
        }</span>
        <span class="cov8" title="1">r.children = append(r.children, child)</span>
}

func (r *BaseRenderObject) RemoveChild(child RenderObject) <span class="cov8" title="1">{
        for i, c := range r.children </span><span class="cov8" title="1">{
                if c == child </span><span class="cov8" title="1">{
                        if baseChild, ok := child.(*BaseRenderObject); ok </span><span class="cov8" title="1">{
                                baseChild.parent = nil
                        }</span>
                        <span class="cov8" title="1">r.children = append(r.children[:i], r.children[i+1:]...)
                        return</span>
                }
        }
}

func (r *BaseRenderObject) ClearChildren() <span class="cov8" title="1">{
        for _, child := range r.children </span><span class="cov8" title="1">{
                if baseChild, ok := child.(*BaseRenderObject); ok </span><span class="cov8" title="1">{
                        baseChild.parent = nil
                }</span>
        }
        <span class="cov8" title="1">r.children = nil</span>
}

// Paint provides a default implementation that paints children
func (r *BaseRenderObject) Paint(context engine.RenderContext) <span class="cov8" title="1">{
        // Paint background if style specifies it
        if r.style.BackgroundColor.A &gt; 0 </span><span class="cov8" title="1">{
                engine.FillRect(
                        context,
                        geometry.Rect{
                                Min: geometry.Point{X: 0, Y: 0},
                                Max: geometry.Point{X: r.size.Width, Y: r.size.Height},
                        },
                        r.style.ForegroundColor,
                        r.style.BackgroundColor,
                )
        }</span>

        // Paint children
        <span class="cov8" title="1">for _, child := range r.children </span><span class="cov8" title="1">{
                child.Paint(context)
        }</span>
}

// Helper functions

// paintBackground fills a rectangle with the background color
func paintBackground(ctx engine.RenderContext, style WidgetStyle, rect geometry.Rect) <span class="cov8" title="1">{
        for y := rect.Min.Y; y &lt; rect.Max.Y; y++ </span><span class="cov8" title="1">{
                for x := rect.Min.X; x &lt; rect.Max.X; x++ </span><span class="cov8" title="1">{
                        ctx.DrawCell(x, y, ' ', style.ForegroundColor, style.BackgroundColor)
                }</span>
        }
}

// NewBaseRenderObject creates a new BaseRenderObject with the given style
func NewBaseRenderObject(style WidgetStyle) *BaseRenderObject <span class="cov8" title="1">{
        return &amp;BaseRenderObject{
                style:    style,
                children: make([]RenderObject, 0),
        }
}</span>

// RenderBox adds box-model functionality to RenderObject
type RenderBox interface {
        RenderObject

        // Box model
        PaintBorder(context engine.RenderContext)
        PaintBackground(context engine.RenderContext)
        PaintContent(context engine.RenderContext)

        // Layout helpers
        ContentRect() geometry.Rect
        PaddingRect() geometry.Rect
        BorderRect() geometry.Rect
        MarginRect() geometry.Rect
}

// BaseRenderBox provides box model implementation
type BaseRenderBox struct {
        BaseRenderObject
}

func (r *BaseRenderBox) Paint(context engine.RenderContext) <span class="cov8" title="1">{
        r.PaintBackground(context)
        r.PaintBorder(context)
        r.PaintContent(context)
}</span>

func (r *BaseRenderBox) PaintBackground(context engine.RenderContext) <span class="cov8" title="1">{
        if r.style.BackgroundColor.A &gt; 0 </span><span class="cov8" title="1">{
                paintBackground(context, r.style, r.PaddingRect())
        }</span>
}

func (r *BaseRenderBox) PaintBorder(context engine.RenderContext) {<span class="cov8" title="1">
        // Implementation depends on border style
        // Will be implemented when we add border styles
}</span>

func (r *BaseRenderBox) PaintContent(context engine.RenderContext) <span class="cov8" title="1">{
        for _, child := range r.children </span><span class="cov8" title="1">{
                child.Paint(context)
        }</span>
}

func (r *BaseRenderBox) ContentRect() geometry.Rect <span class="cov8" title="1">{
        insets := r.style.Padding
        return geometry.Rect{
                Min: geometry.Point{X: insets.Left, Y: insets.Top},
                Max: geometry.Point{
                        X: r.size.Width - insets.Right,
                        Y: r.size.Height - insets.Bottom,
                },
        }
}</span>

func (r *BaseRenderBox) PaddingRect() geometry.Rect <span class="cov8" title="1">{
        return geometry.Rect{
                Min: geometry.Point{X: 0, Y: 0},
                Max: geometry.Point{X: r.size.Width, Y: r.size.Height},
        }
}</span>

func (r *BaseRenderBox) BorderRect() geometry.Rect <span class="cov8" title="1">{
        insets := r.style.Margin
        return geometry.Rect{
                Min: geometry.Point{X: -insets.Left, Y: -insets.Top},
                Max: geometry.Point{
                        X: r.size.Width + insets.Right,
                        Y: r.size.Height + insets.Bottom,
                },
        }
}</span>

func (r *BaseRenderBox) MarginRect() geometry.Rect <span class="cov8" title="1">{
        border := r.BorderRect()
        insets := r.style.Margin
        return geometry.Rect{
                Min: geometry.Point{
                        X: border.Min.X - insets.Left,
                        Y: border.Min.Y - insets.Top,
                },
                Max: geometry.Point{
                        X: border.Max.X + insets.Right,
                        Y: border.Max.Y + insets.Bottom,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package widget

import (
        "github.com/watzon/tide/pkg/core/capabilities"
        "github.com/watzon/tide/pkg/core/color"
        "github.com/watzon/tide/pkg/core/geometry"
        "github.com/watzon/tide/pkg/core/style"
)

// WidgetStyle extends core.style.Style with widget-specific styling
type WidgetStyle struct {
        style.Style // Embed core style

        // Layout properties
        Padding EdgeInsets
        Margin  EdgeInsets
        MinSize geometry.Size
        MaxSize geometry.Size

        // Border properties
        BorderStyle BorderStyle
        BorderColor color.Color
        BorderWidth EdgeInsets
}

// BorderStyle represents different border types
type BorderStyle int

const (
        BorderNone BorderStyle = iota
        BorderSingle
        BorderDouble
        BorderRounded
        BorderHeavy
        BorderDashed
        BorderDotted
)

// NewWidgetStyle creates a new style with default values
func NewWidgetStyle() WidgetStyle <span class="cov8" title="1">{
        return WidgetStyle{
                Style: style.Style{
                        ForegroundColor: color.White,
                        BackgroundColor: color.Transparent,
                },
                Padding:     EdgeInsets{},
                Margin:      EdgeInsets{},
                BorderStyle: BorderNone,
                BorderColor: color.Transparent,
                BorderWidth: EdgeInsets{},
        }
}</span>

// Style modification methods (fluent interface)
func (s WidgetStyle) WithForeground(c color.Color) WidgetStyle <span class="cov8" title="1">{
        s.ForegroundColor = c
        return s
}</span>

func (s WidgetStyle) WithBackground(c color.Color) WidgetStyle <span class="cov8" title="1">{
        s.BackgroundColor = c
        return s
}</span>

func (s WidgetStyle) WithBold(bold bool) WidgetStyle <span class="cov8" title="1">{
        s.Bold = bold
        return s
}</span>

func (s WidgetStyle) WithItalic(italic bool) WidgetStyle <span class="cov8" title="1">{
        s.Italic = italic
        return s
}</span>

func (s WidgetStyle) WithUnderline(underline bool) WidgetStyle <span class="cov8" title="1">{
        s.Underline = underline
        return s
}</span>

func (s WidgetStyle) WithStrikeThrough(strikeThrough bool) WidgetStyle <span class="cov8" title="1">{
        s.StrikeThrough = strikeThrough
        return s
}</span>

func (s WidgetStyle) WithPadding(insets EdgeInsets) WidgetStyle <span class="cov8" title="1">{
        s.Padding = insets
        return s
}</span>

func (s WidgetStyle) WithMargin(insets EdgeInsets) WidgetStyle <span class="cov8" title="1">{
        s.Margin = insets
        return s
}</span>

func (s WidgetStyle) WithBorder(style BorderStyle, color color.Color, width EdgeInsets) WidgetStyle <span class="cov8" title="1">{
        s.BorderStyle = style
        s.BorderColor = color
        s.BorderWidth = width
        return s
}</span>

// Merge combines two styles, with the other style taking precedence
func (s WidgetStyle) Merge(other WidgetStyle) WidgetStyle <span class="cov8" title="1">{
        result := s

        // Only override colors if they're not transparent
        if other.ForegroundColor.A &gt; 0 </span><span class="cov8" title="1">{
                result.ForegroundColor = other.ForegroundColor
        }</span>
        <span class="cov8" title="1">if other.BackgroundColor.A &gt; 0 </span><span class="cov0" title="0">{
                result.BackgroundColor = other.BackgroundColor
        }</span>

        // Text properties
        <span class="cov8" title="1">result.Bold = result.Bold || other.Bold
        result.Italic = result.Italic || other.Italic
        result.Underline = result.Underline || other.Underline
        result.StrikeThrough = result.StrikeThrough || other.StrikeThrough

        // Layout properties (other takes precedence)
        result.Padding = other.Padding
        result.Margin = other.Margin

        // Border properties
        if other.BorderStyle != BorderNone </span><span class="cov8" title="1">{
                result.BorderStyle = other.BorderStyle
                result.BorderColor = other.BorderColor
                result.BorderWidth = other.BorderWidth
        }</span>

        <span class="cov8" title="1">return result</span>
}

// AdaptStyle adapts the style for specific backend capabilities
func (s WidgetStyle) AdaptStyle(caps capabilities.Capabilities) WidgetStyle <span class="cov8" title="1">{
        adapted := s

        // Adapt colors based on backend capabilities
        if caps.ColorMode &lt; capabilities.ColorTrueColor </span><span class="cov8" title="1">{
                adapted.ForegroundColor = adapted.ForegroundColor.QuantizeTo(color.ColorMode(caps.ColorMode))
                adapted.BackgroundColor = adapted.BackgroundColor.QuantizeTo(color.ColorMode(caps.ColorMode))
                if adapted.BorderColor.A &gt; 0 </span><span class="cov8" title="1">{
                        adapted.BorderColor = adapted.BorderColor.QuantizeTo(color.ColorMode(caps.ColorMode))
                }</span>
        }

        // Remove unsupported text styles
        <span class="cov8" title="1">if !caps.SupportsItalic </span><span class="cov8" title="1">{
                adapted.Italic = false
        }</span>
        <span class="cov8" title="1">if !caps.SupportsBold </span><span class="cov8" title="1">{
                adapted.Bold = false
        }</span>
        <span class="cov8" title="1">if !caps.SupportsUnderline </span><span class="cov8" title="1">{
                adapted.Underline = false
        }</span>
        <span class="cov8" title="1">if !caps.SupportsStrikethrough </span><span class="cov8" title="1">{
                adapted.StrikeThrough = false
        }</span>

        <span class="cov8" title="1">return adapted</span>
}

// Helper functions for common style combinations
func (s WidgetStyle) Disabled() WidgetStyle <span class="cov8" title="1">{
        return s.WithForeground(s.ForegroundColor.WithAlpha(128))
}</span>

func (s WidgetStyle) Selected() WidgetStyle <span class="cov8" title="1">{
        return s.WithBackground(color.Color{R: 0, G: 0, B: 128, A: 255})
}</span>

func (s WidgetStyle) Focused() WidgetStyle <span class="cov8" title="1">{
        return s.WithBorder(BorderSingle, color.Color{R: 0, G: 128, B: 255, A: 255}, EdgeInsets{
                Top: 1, Right: 1, Bottom: 1, Left: 1,
        })
}</span>

// Common style presets
var (
        DefaultStyle = NewWidgetStyle()

        PrimaryStyle = NewWidgetStyle().
                        WithForeground(color.Color{R: 0, G: 122, B: 255, A: 255})

        SuccessStyle = NewWidgetStyle().
                        WithForeground(color.Color{R: 40, G: 167, B: 69, A: 255})

        WarningStyle = NewWidgetStyle().
                        WithForeground(color.Color{R: 255, G: 193, B: 7, A: 255})

        ErrorStyle = NewWidgetStyle().
                        WithForeground(color.Color{R: 220, G: 53, B: 69, A: 255})
)
</pre>
		
		<pre class="file" id="file7" style="display: none">package widget

import (
        "fmt"

        "github.com/watzon/tide/pkg/core/geometry"
)

// Key uniquely identifies a widget in the tree
type Key interface {
        String() string
}

// Widget is the base interface for all widgets
type Widget interface {
        // Core identity
        GetKey() Key
        GetType() string

        // Layout
        GetConstraints() Constraints
        GetSize() geometry.Size

        // Building
        Build(context BuildContext) Widget

        // Rendering
        CreateRenderObject() RenderObject
        UpdateRenderObject(RenderObject)
}

// BaseWidget provides common functionality for all widgets
type BaseWidget struct {
        key         Key
        constraints Constraints
        size        geometry.Size
        style       WidgetStyle
}

// Identity methods
func (w *BaseWidget) GetKey() Key <span class="cov8" title="1">{
        return w.key
}</span>

func (w *BaseWidget) GetType() string <span class="cov8" title="1">{
        return fmt.Sprintf("%T", w)
}</span>

// Layout methods
func (w *BaseWidget) GetConstraints() Constraints <span class="cov8" title="1">{
        return w.constraints
}</span>

func (w *BaseWidget) GetSize() geometry.Size <span class="cov8" title="1">{
        return w.size
}</span>

// Style methods
func (w *BaseWidget) GetStyle() WidgetStyle <span class="cov8" title="1">{
        return w.style
}</span>

func (w *BaseWidget) WithStyle(style WidgetStyle) *BaseWidget <span class="cov8" title="1">{
        w.style = style
        return w
}</span>

// Builder methods - these should be overridden by implementing widgets
func (w *BaseWidget) Build(context BuildContext) Widget <span class="cov8" title="1">{
        return w // Base widgets are leaves by default
}</span>

func (w *BaseWidget) CreateRenderObject() RenderObject <span class="cov8" title="1">{
        return &amp;BaseRenderObject{
                style: w.style,
        }
}</span>

func (w *BaseWidget) UpdateRenderObject(renderObject RenderObject) <span class="cov8" title="1">{
        if baseRenderObject, ok := renderObject.(*BaseRenderObject); ok </span><span class="cov8" title="1">{
                baseRenderObject.style = w.style
        }</span>
}

// WithKey sets a key for the widget
func (w *BaseWidget) WithKey(key Key) *BaseWidget <span class="cov8" title="1">{
        w.key = key
        return w
}</span>

// WithConstraints sets constraints for the widget
func (w *BaseWidget) WithConstraints(constraints Constraints) *BaseWidget <span class="cov8" title="1">{
        w.constraints = constraints
        return w
}</span>

// MockWidget implements Widget interface for testing
type MockWidget struct {
        BaseWidget
        size        geometry.Size
        constraints Constraints
        buildResult Widget
        shouldBuild bool
}

func (w *MockWidget) GetSize() geometry.Size <span class="cov8" title="1">{
        return w.size
}</span>

func (w *MockWidget) GetConstraints() Constraints <span class="cov8" title="1">{
        return w.constraints
}</span>

func (w *MockWidget) Build(context BuildContext) Widget <span class="cov8" title="1">{
        if !w.shouldBuild </span><span class="cov8" title="1">{
                return w // Don't build children by default
        }</span>
        <span class="cov8" title="1">if w.buildResult != nil </span><span class="cov8" title="1">{
                return w.buildResult
        }</span>
        <span class="cov0" title="0">return w</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
